def is_prime(n):
    """
    Função para verificar se um número é primo.
    Retorna True se n é primo, False caso contrário.
    """
    if n < 2:
        return False
    for i in range(2, int(n**(0.5))+1):
        if n % i == 0:
            return False
    return True

def josephus(n):
    # Criando lista circular com os valores de 1 a n
    people = list(range(1, n+1))
    # Variável para controlar o índice atual na lista
    idx = 0
    # Variável para controlar o número primo atual
    prime = 2
    
    while len(people) > 1:
        # Calculando o próximo número primo
        while not is_prime(prime):
            prime += 1
        
        # Encontrando a pessoa a ser eliminada
        idx_to_remove = (idx + prime - 1) % len(people)
        # Removendo a pessoa da lista
        people.pop(idx_to_remove)
        # Atualizando o índice atual
        idx = idx_to_remove % len(people)
        # Atualizando o número primo atual
        prime += 1
    
    # Retornando a posição da pessoa salva (o único elemento que resta na lista)
    return people[0]

# Lendo os valores de n da entrada
while True:
    n = int(input())
    if n == 0:
        break
    # Chamando a função josephus e imprimindo o resultado
    print(josephus(n))
    
    
    ****************************************************
    
def is_prime(n):
    
    if n < 2:
        return False
    for i in range(2, int(n**(0.5))+1):
        if n % i == 0:
            return False
    return True

def josephus(n):
    people = list(range(1, n+1))
    idx = 0
    prime = 2
    
    while len(people) > 1:
        while not is_prime(prime):
            prime += 1
        
        idx_to_remove = (idx + prime - 1) % len(people)
        people.pop(idx_to_remove)
        idx = idx_to_remove % len(people)
        prime += 1
    
    return people[0]

while True:
    n = int(input())
    if n == 0:
        break
    print(josephus(n))

*************************************

Esse programa implementa o problema de Josephus, que é um antigo problema matemático que descreve uma situação de sobrevivência. 
A situação descrita é a seguinte: um grupo de n pessoas está em uma roda, 
numeradas de 1 a n. A partir da pessoa 1, é contado até a pessoa k e essa pessoa é removida da roda. 
O processo se repete, com a contagem iniciando na pessoa seguinte à pessoa removida e indo até a pessoa k seguinte. 
O processo continua até que apenas uma pessoa permaneça na roda. O objetivo do problema é determinar 
qual é a posição dessa pessoa sobrevivente.

O programa começa definindo uma função is_prime(n) que verifica se um número n é primo. Para isso, ele primeiro verifica 
se n é menor que 2, pois 0 e 1 não são considerados primos. Em seguida, ele faz um loop que vai de 2 até a raiz 
quadrada de n, verificando se o resto da divisão de n por cada número no loop é igual a zero. Se n for divisível 
por algum número no loop, a função retorna False, indicando que n não é primo. Se nenhum dos números no loop for 
um fator de n, a função retorna True, indicando que n é primo.

Em seguida, o programa define a função josephus(n), que recebe um número inteiro n como entrada e retorna a posição da pessoa 
sobrevivente no problema de Josephus descrito acima. Ele começa criando uma lista people com os números de 1 a n. A variável idx 
é inicializada com 0 e a variável prime é inicializada com 2.

O programa então entra em um loop while que continua até que haja apenas uma pessoa restante na lista people. Dentro desse loop, 
ele entra em outro loop while que continua até que prime seja um número primo. Ele faz isso chamando a função is_prime(prime) e 
incrementando prime em 1 enquanto o resultado for False.

Uma vez que prime é um número primo, o programa calcula a posição da pessoa a ser removida como (idx + prime - 1) % len(people). 
Essa posição é removida da lista people usando o método pop(). O índice idx é atualizado como idx_to_remove % len(people) e prime 
é incrementado em 1. O loop continua até que apenas uma pessoa reste na lista people.

Finalmente, o programa retorna a posição da única pessoa restante na lista people[0]. O programa continua executando em um loop 
while que lê um número inteiro n da entrada padrão até que n seja igual a 0, e imprime o resultado da função josephus(n).

***********************************

Esse conjunto de códigos é um programa que resolve o problema do Josephus. O problema de Josephus é um problema teórico em matemática 
e ciência da computação. O problema é assim:

N pessoas (numeradas de 1 a N) estão sentadas em uma mesa circular. De repente, começa um jogo em que a primeira pessoa, 
ou seja, a pessoa de número 1, é morta e retirada da mesa. Em seguida, a pessoa seguinte (ou seja, a pessoa de número 2) 
é morta e retirada da mesa, e o jogo continua no sentido horário até que apenas uma pessoa permaneça. O objetivo do jogo 
é determinar quem será a última pessoa que permanecerá sentada na mesa.

Para resolver esse problema, o programa define duas funções: is_prime e josephus.

A função is_prime verifica se um número é primo ou não. Se o número for menor que 2, a função retorna False. 
Se o número for maior ou igual a 2, a função verifica se ele é divisível por algum número inteiro entre 2 e a 
raiz quadrada do número (int(n**(0.5))+1). Se o número for divisível por algum desses números, a função retorna False. 
Caso contrário, a função retorna True.

A função josephus usa a lista people para representar as pessoas sentadas na mesa circular. A variável idx é o 
índice da pessoa que será morta na próxima rodada do jogo. A variável prime é o próximo número primo. O programa 
entra em um loop enquanto a lista people tiver mais de uma pessoa. Dentro do loop, o programa entra em outro loop 
enquanto o número primo não for encontrado. Quando o número primo é encontrado, o índice da pessoa a ser morta na 
próxima rodada é calculado usando a fórmula (idx + prime - 1) % len(people), onde len(people) é o comprimento da lista people. 
Essa fórmula calcula o índice da pessoa que está localizada prime posições à direita da pessoa atual idx, levando em consideração 
o fato de que a lista people é circular. Depois disso, a pessoa correspondente é removida da lista people usando o método pop. 
O novo valor de idx é calculado como idx_to_remove % len(people), onde idx_to_remove é o índice da pessoa que acabou de ser removida. 
Finalmente, o número primo é incrementado em 1 e o loop continua até que apenas uma pessoa permaneça na lista people. 
O número da última pessoa que permanece na lista é retornado pela função josephus.

O loop while True no final do programa lê o valor de n a partir da entrada padrão e imprime o resultado da função josephus para cada valor de n até que n seja igual a 0. Quando n é igual a 0, o programa sai do loop usando a instrução break.
