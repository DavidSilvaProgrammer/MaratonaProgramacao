def eh_primo(n):
    
    if n < 2:
        return False
    for i in range(2, int(n**(0.5))+1):
        if n % i == 0:
            return False
    return True
    
/*
A função eh_primo recebe n como parametro e retorna falso se o número for menor que 2. E tem um range que vai até a raiz quadrada de n +1, sendo este +1 colocado pelo motivo de um vetor começar sempre em 0. Assim, na condição if é feito o módulo de n por i, de modo que se esse retorna zero é porque aconteceu uma divisão inteira e esse número não é primo, logo retornará falso. Caso a condição if não seja acionada, a função retornará verdadeiro, confirmando que se trata de um número primo.
*/

def primo_josephus(n):
    pessoas = list(range(1, n+1))
    pos = 0
    pulo_primo = 2
    
    while len(pessoas) > 1:
        while not eh_primo(primo):
            pulo_primo += 1
        
        remove_indice = (pos + primo - 1) % len(pessoas)
        pessoas.pop(remove_indice)
        pos = remove_indice % len(pessoas)
        primo += 1
    
    return pessoas[0]
    
/*
A função primo_josephus recebe n como parametro e cria a lista pessoas que vai de 1 até n+1, Obs: É necessário colocar esse +1 porque a função range encerra antes do ultimo número.
Após isso, é necessário declarar duas variaveis, pos de posição e primo valendo 2, já que é o primeiro número primo que será ultilizado.

Depois vem um laço while que só será encerrado quando apenas sobrar um elemento na lista. Em seguinda, vem mais um laço while que servirá para capturar o próximo número primo que será utilizado no pulo.

Então fora desse ciclo de captura de primos, mas ainda dentro do ciclo da lista pessoas ter um unico elemento, tem a variavel "remove_indice" que vai remover um elemento da lista com base no valor da posição somando com a variavel primo, que representa o valor do pulo, subtraindo 1 por causa do vetor começar no zero e tirando o modulo por pelo valor da função len que está retornando o número de elementos na lista pessoas. Isso é feito para que o valor dos pulos feitos com base nos valores dos números primos não ultrapassem a quantidade de elementos na lista.

Após isso no fim do laço coloco primo recebendo +1, afim de que o laço "while not eh_primo(primo)" seja acionado
novamente em busca do novo número primo que servirá como
pulo. Dessa forma, o programa segue até que só reste o elemento do indice 0 na lista pessoas.


*/

while True:
    n = int(input())
    if n == 0:
        break
    print(primo_josephus(n))
    
/*
Finalmente, na função main, é dado ao usuário a opção de inserir o valor de entrada na variavel n. Tem uma um if que encerra o programa caso o número digitado seja 0 e
é impresso no fim o elemento de indice 0 que retorna na função primo_joseph que recebeu o valor de n que o usuário digitou.
*/
